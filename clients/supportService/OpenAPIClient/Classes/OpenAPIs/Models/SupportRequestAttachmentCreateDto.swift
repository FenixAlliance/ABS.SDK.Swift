//
// SupportRequestAttachmentCreateDto.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct SupportRequestAttachmentCreateDto: Codable, JSONEncodable, Hashable {

    static let businessIDRule = StringRule(minLength: 36, maxLength: 36, pattern: nil)
    static let businessProfileRecordIDRule = StringRule(minLength: 36, maxLength: 36, pattern: nil)
    public var id: UUID?
    public var timestamp: Date?
    public var notes: String?
    public var title: String?
    public var author: String?
    public var isFolder: Bool?
    public var fileName: String?
    public var abstract: String?
    public var keyWords: String?
    public var validResponse: Bool?
    public var parentFileUploadId: String?
    public var filePath: String?
    public var file: URL?
    public var businessID: String?
    public var businessProfileRecordID: String?
    public var metadata: String?
    public var supportRequestID: String?

    public init(id: UUID? = nil, timestamp: Date? = nil, notes: String? = nil, title: String? = nil, author: String? = nil, isFolder: Bool? = nil, fileName: String? = nil, abstract: String? = nil, keyWords: String? = nil, validResponse: Bool? = nil, parentFileUploadId: String? = nil, filePath: String? = nil, file: URL? = nil, businessID: String? = nil, businessProfileRecordID: String? = nil, metadata: String? = nil, supportRequestID: String? = nil) {
        self.id = id
        self.timestamp = timestamp
        self.notes = notes
        self.title = title
        self.author = author
        self.isFolder = isFolder
        self.fileName = fileName
        self.abstract = abstract
        self.keyWords = keyWords
        self.validResponse = validResponse
        self.parentFileUploadId = parentFileUploadId
        self.filePath = filePath
        self.file = file
        self.businessID = businessID
        self.businessProfileRecordID = businessProfileRecordID
        self.metadata = metadata
        self.supportRequestID = supportRequestID
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case timestamp
        case notes
        case title
        case author
        case isFolder
        case fileName
        case abstract
        case keyWords
        case validResponse
        case parentFileUploadId
        case filePath
        case file
        case businessID
        case businessProfileRecordID
        case metadata
        case supportRequestID
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encodeIfPresent(timestamp, forKey: .timestamp)
        try container.encodeIfPresent(notes, forKey: .notes)
        try container.encodeIfPresent(title, forKey: .title)
        try container.encodeIfPresent(author, forKey: .author)
        try container.encodeIfPresent(isFolder, forKey: .isFolder)
        try container.encodeIfPresent(fileName, forKey: .fileName)
        try container.encodeIfPresent(abstract, forKey: .abstract)
        try container.encodeIfPresent(keyWords, forKey: .keyWords)
        try container.encodeIfPresent(validResponse, forKey: .validResponse)
        try container.encodeIfPresent(parentFileUploadId, forKey: .parentFileUploadId)
        try container.encodeIfPresent(filePath, forKey: .filePath)
        try container.encodeIfPresent(file, forKey: .file)
        try container.encodeIfPresent(businessID, forKey: .businessID)
        try container.encodeIfPresent(businessProfileRecordID, forKey: .businessProfileRecordID)
        try container.encodeIfPresent(metadata, forKey: .metadata)
        try container.encodeIfPresent(supportRequestID, forKey: .supportRequestID)
    }
}

